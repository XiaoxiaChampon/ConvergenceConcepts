---
title: "Convergence Concepts for Statisticians"
author: "Xiaoxia Champon, Justin Post"
date: "2023-04-25"
output: 
  html_document:
    css: "style.css"
runtime: shiny
---

```{js, echo = FALSE}
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
```

```{r setup, include=FALSE,warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#add library
library(shiny)
library(shinydashboard)
library(ConvergenceConcepts)
```


# Motivation

A [Pew Research Center survey of 10,701 U.S. adults was conducted in March 2023](https://www.pewresearch.org/science/2023/05/16/americans-largely-positive-views-of-childhood-vaccines-hold-steady/). The survey asked participants questions related to their thoughts on vaccination. One question centered around the perceived efficacy of the MMR vaccine.

<div style = "float:right">
```{r, echo = FALSE, out.width = "400px"}
knitr::include_graphics("img/pew.jpg")
```
</div>

The Center survey finds 88% of Americans say the benefits of childhood vaccines for measles, mumps and rubella (MMR) outweigh the risks, compared with just 10% who say the risks outweigh the benefits.

The sample proportion of 0.88 is an estimate of the population proportion. That is, the actual proportion of U.S. adults that believe the benefits outweigh the risks. 

Of course this is a single number estimate that would change if we sampled again. We can report the standard deviation of this sample proportion, called a standard error, to give us an idea of the variability in the estimate.  

Assuming independence between study participants, we can find an estimated standard error for this sample proportion using techniques learned eariler:

$$\widehat{SE(\hat{p})} = \sqrt{\frac{\hat{p}(1-\hat{p})}{n}} \approx \sqrt{\frac{0.88*0.12}{10701}} = 0.0031$$
Two big questions arise:

- First, can we provide a range of values we are 'confident' the true proportion falls in?
    + We need to know about more than just the variability of the estimator
    + We need to understand the **distribution** of the estimator!
        - Called the **sampling distribution**
        - Describes the pattern in which we observe this $\hat{p}$
    + The sampling distribution can be difficult to derive in some cases!
- Second, ideally we'd like for our estimator to get closer to the true proportion for larger sample sizes
    + Is there a value that $\hat{p}$ *converges* to as n grows?
    + What does it even mean for a random quantity to converge?
    
These two questions can often be answered by looking at the *limiting* behavior (here as the sample size grows) of the estimator $\hat{p}$.


## Convergence in Distribution Idea

To answer the first question, let's consider determining the sampling distribution through simulation. A distribution just describes the pattern in which we observe our variable. If we can simulate observing the variable, we can create many *realizations* of $\hat{p}$ to understand the sampling distribution. 

To do this we need to make some assumptions. We need to assume a true $p$ and a sample size $n$. Let's use the app below to consider the sampling distribution when $p$ is 0.9 and $n$ is 100.

```{r, echo = FALSE}
shinyApp(
  ui <- fluidPage(
    #inputs on the side for n, p, and generating data
    sidebarPanel(
      sliderInput("sample_size",
                  "n: sample size",
                  min = 1,
                  max = 500,
                  step= 1,
                  value = 100),
      sliderInput("true_p",
                  "p: true value in population",
                  min = 0,
                  max = 1,
                  step= 0.01,
                  value = 0.9),
      actionButton("gen",
                   "Generate a sample proportion"),
      actionButton("gen100",
                   "Generate 100 sample proportions"),
      checkboxInput("bars", 
                    "Add +/- 2 Standard Errors and\nOverlay Smoothed Density",
                    value = FALSE)
    ),
    mainPanel(
      plotOutput("samp_dist")
    )
  ),
  server <- function(input, output, session){
      ys <- reactiveValues(y = c(), n = 0)

      observeEvent(input$gen, 
                   {
                     ys$y <- c(ys$y, rbinom(1, size = input$sample_size, prob = input$true_p))
                     ys$n <- ys$n + 1
                     }
                   )
      
      observeEvent(input$gen100, 
                   {
                     ys$y <- c(ys$y, rbinom(100, size = input$sample_size, prob = input$true_p))
                     ys$n <- ys$n + 100
                     }
       )
      
      observeEvent(c(input$sample_size, input$true_p), 
                   {
                     ys$y <- c()
                     ys$n <- 0
                     }
                   )
            
      output$samp_dist <- renderPlot({
        props <- ys$y/input$sample_size
        if(length(props) > 0) {
          hist(props, 
               xlab = "Sample Proportions", 
               main = paste0("Sampling Distribution of p-hat\n# of sample proportions plotted: ", ys$n),
               freq = FALSE)
          if(input$bars){
            se <- sqrt(input$true_p*(1-input$true_p)/input$sample_size)
            bounds <- c(input$true_p - 2*se, input$true_p + 2*se)
            abline(v = bounds, col = "red", lwd = 2)
            
            text(x = input$true_p + 0.5*se, y = 2, labels = paste0(round(mean(props <= bounds[2] & props >= bounds[1]), 2), " of the distribution\nbetween the bars"))
            lines(density(props, kernel = "gaussian", adjust = 2))
          }
        } else {
          NULL
        }
      })
  }
)
```

As long as the distribution is roughly normal, we can see that 0.95 of the distribution falls within two standard errors of $p$. This means we could use something like 

$$\hat{p}\pm 2*\widehat{SE(\hat{p})}$$

as an interval to *capture* the true $p$. (Indeed this is the usual basic interval for a proportion!)


## Convergence in Probability Idea

To answer the second question, we could consider generating sample proportions for ever increasing values of the sample size and seeing how they behave. Below generate sample proportions and subtract off the true value of $p$, plotting those differences.

```{r, echo = FALSE}
shinyApp(
  ui <- fluidPage(
    #inputs on the side for n, p, and generating data
    sidebarPanel(
      numericInput("max_size",
                   "Maximum Sample Size",
                   value = 250,
                   min = 10, 
                   max = 5000),
      sliderInput("num_samples",
                  "# samples at each n",
                  min = 1,
                  max = 10,
                  step= 1,
                  value = 1),
      sliderInput("true_p",
                  "p: true value in population",
                  min = 0,
                  max = 1,
                  step= 0.01,
                  value = 0.5),
      actionButton("create",
                   "Create/Update graph")
    ),
    mainPanel(
      plotOutput("convergence")
    )
  ),
  server <- function(input, output, session){
      ps <- reactiveValues(p = c())

      observeEvent(input$create, 
                   {
                     ps$p <- sapply(1:input$max_size, FUN = function(x){
                       rbinom(n = input$num_samples, 
                              size = x,
                              prob = input$true_p)/x
                       })
                     }
                   )
            
      output$convergence <- renderPlot({
        props <- ps$p
        truth <- isolate(input$true_p)
        num <- isolate(input$num_samples)
        max_size <- isolate(input$max_size)
        ep <- 0.05
        if(length(props) == 0) {
          plot(x = NULL, 
               y = NULL, 
               xlim = c(0, max_size), 
               ylim = c(-0.5, 0.5),
               xlab = "Sample Size",
               ylab = "phat-p",
               main = "Plot of sample proportion minus the true proportion\nRed lines indicate +/- 0.05")
          abline(h = c(-ep, ep), col = "red", lwd = 2)
        } else {
          plot(x = rep(1:max_size, each = num), y = c(props)-truth, 
               main = "Plot of sample proportion minus the true proportion\nRed lines indicate +/- 0.05",
               xlab = "Sample Size",
               ylab = "phat - p",
               type = "p")
          abline(h = c(-ep, ep), col = "red", lwd = 2)
        }
      })
  }
)
```

We can see that $\hat{p}-p$ seems to get closer to 0. This indicates that $\hat{p}$ is in some sense *converging* to the true value of $p$!

Now that we some basic intution, let's formalize what we are talking about.

# What is Limit Theory?

By limit, large-sample, or asymptotic theory we mean we want to understand the behavior of some quantity, usually a statistic, as something changes, usually the sample size $n$. For instance, we will investigate the behavior of the sample mean, $\bar{Y}$, as the sample size grows. We'll look at questions like:

- When the distribution of a statistic (called a **sampling distribution**) is difficult to derive *exactly*, is there a good **approximating** distribution that can be used to get **approximate** probability statements about $\bar{Y}$?
- What value does $\bar{Y}$ *get close to* or *converge* to as the sample size grows? 

Answers to these questions will allows us to do inference (confidence intervals and hypothesis tests) and understand how well we are estimating a quantity, respectively.

## Common Assumptions & Definitions

We must make some assumptions about how we observe our random variables in order to investigate these types of questions. For simplicity, we often assume we have a **random sample**.

Random Sample
: $Y_1,..., Y_n$ are a random sample (RS) of size $n$ if the random variables are independent and identically distributed (iid). 

We'll often say 'assume we have a random sample' from some distribution or that 'our random variables are iid' from some distribution. These are equivalent ways of stating this assumption.

For the proportion example above we might formally state our assumption as follows:
- Define $X_i$ as 1 if the $i^{th}$ individual says the benefits of childhood vaccines for measles, mumps and rubella (MMR) outweigh the risks and $X_i$ = 0 if not
- Then $X_i\stackrel{iid}\sim Ber(p)$ where $p$ represents the true proportion of people in the U.S. that believe the benefits outweight the risks
- The random variable $Y = \sum_{i=1}^{n}X_i \sim Bin(n,p)$
- We then often try to use $Y$ or $\hat{p}=Y/n$ to make inference on $p$. $Y$ and $\hat{p}$ are referred to as **statistics**.

Statistic
: A function of $Y_1,Y_2,...,Y_n$ from a random sample that does not involve any unknown parameters is called a statistic.

Commonly studied statistics:  

- $\bar{Y} = \frac{1}{n}\sum_{i=1}^n Y_i$
    + Note: The sample proportion above is really the mean of the $X_i$ variables!
- $S^2 = \frac{1}{n-1}\sum_{i=1}^{n}(Y_i-\bar{Y})^2$
- $Y_{(n)} = \mbox{the maximum value from the sample}$

Quantities that aren't statistics:  

- $\frac{\bar{Y}-\mu}{S/\sqrt{n}}$ (since $\mu$ is unknown - if we assume $\mu$ is known (like when we do a test statistic) then this is a statistic)
- $\frac{(n-1)S^2}{\sigma^2}$ (since $\sigma^2$ is unknown)

One type of convergence we'll look at is focused on the pattern in which these statistics are observed, that is, the **sampling distribution** of the statistics.

Recall that a distribution is just the pattern and frequency with which we observe a random variable. With a statistic, we give this distribution the special name of sampling distribution. This is because we can think of how that distribution is formed by considering repeated samples from the population, each sample producing the statistic of interest.

Sampling Distribution
: The distribution of a statistic is called a sampling distribution.

# Convergence in Distribution 

We saw with the simulation earlier that the distribution of $\hat{p}$ seemed to look like a bell curve for some combinations of $n$ and $p$. If we fix a $p$ and increase $n$, we will start to see a bell shape for large enough $n$! Later we'll see that a good **large-sample** distribution for $\hat{p}$ is the normal distribution with mean $p$ and variance $p(1-p)/n$.  

We can see that there may be a distinction between the *actual* distribution and an approximating distribution. We call these by different names.

Exact Distribution
: The (sampling) distribution of a quantity that is valid for any sample size (or, occasionally, values of the parameters of the population distribution).

Large-Sample or Approximate Distribution
: A (sampling) distribution that is reasonable to use for a quantity for a *large* sample size (or occasionally other parameter values). 

We use the notation
$$Statistic \stackrel{\bullet}\sim f$$
to denote a large-sample approximating distribution.

In the sample proportion example, we would write

$$\hat{p}\stackrel{\bullet}\sim N(p, p(1-p)/n)$$

While this idea can be visually inspected with a histogram, formally we define **convergence in distribution** using the cumulative distribution function or CDF.

Let's formally define convergence in distribution! Recall the Cumulative Distribution Function (or CDF) of a random variable $Y$ is defined as 

$$F_Y(y) = P(Y\leq y)$$

**Put the Binomial/normal CDF here**

Convergence in Distribution
: The quantity $Y_n$ converges in distribution to $Y$ if
$$\lim_{n \rightarrow \infty} F_{Y_n}(y)=F_{Y}(y)$$
or equivalently
$$\lim_{n \rightarrow \infty} |F_{Y_n}(y)-F_{Y}(y)|=0$$
(at all points $y$ where $F_Y(y)$ is continuous)

For example, given a random sample from a distribution with finite variance, 
$$Z_n = \frac{\bar{Y}_n - \mu}{\sigma/\sqrt{n}}$$
can be shown to converge in distribution to a standard normal distribution. This means that
$$\lim_{n \rightarrow \infty} F_{Z_n}(z)=F_{Z}(z)$$
where $Z\sim N(0,1)$.

Note: Here the subscript $n$ is just to explicitly note the dependence of the quantity on the sample size. We could leave that off if we'd like.







- Suppose that $Y_i\stackrel{iid}\sim Gamma(\alpha = 5, \lambda = 1)$. (That is, assume we have a random sample from a Gamma distribution.) 
- Consider the *statistic* $\bar{Y} = \frac{1}{n}\sum_{i=1}^n Y_i$. 
- We often want to understand the *sampling distribution* of our statistic so that we can make (at least approximate) probabilistic statements about $\bar{Y}$. These will allow us to create **confidence intervals** or **hypothesis tests**, which will be studied later. Given the above example, we can calculate the confidence intervals for the average annual wage for data scientist in Boston, MA or if we can test whether or not the mean yearly income for data scientist is the same between Los Angeles, LA and Washington DC.

How to learn about the sampling distribution? 

A distribution is just the pattern and frequency with which we observe the quantity. With an assumption about how our data is generated (random sample from a gamma distribution with the given parameters), we can easily use software to generate many values of our statistic. We can then plot these values on a histogram to get an idea about the distribution!

**Here we would put stills from the app, but just hard coded, for different sample sizes so we can see the behavior. We note that as $n$ grows we start to see a roughly normally distributed curve.**

Below is the sample mean for different sample sizes 20, 50, 100 and 500 with the gamma distribution such that $Y_i\stackrel{iid}\sim Gamma(\alpha = 5, \lambda = 1)$. We randomly generate the data from known gamma distribution with a fixed sample size and find the mean. We repeat this process for that sample size 1000 times and plot the histogram below for that 1000 means under each sample size.

```{r, echo=FALSE, message=FALSE, eval = FALSE}
options(warn = -1)
library(magick)
library(ggplot2)
library(dplyr)
library(tidyr)
library(gganimate)

alpha=5
lambda=1
M=1000 #number of repetations
n20=c(0)
for (i in 1:M){
  n20[i]=mean(rgamma(n = 20, shape = alpha, scale = lambda) )
}
n50=c(0)

for (i in 1:M){
  n50[i]=mean(rgamma(n = 50, shape = alpha, scale = lambda) )
}

n100=c(0)

for (i in 1:M){
  n100[i]=mean(rgamma(n = 100, shape = alpha, scale = lambda) )
}
n500=c(0)
for (i in 1:M){
  n500[i]=mean(rgamma(n = 500, shape = alpha, scale = lambda) )
}
datamat=data.frame(cbind(c(rep(c(20,50,100,500),each=M)),c(n20,n50,n100,n500)))
colnames(datamat)=c("samplesize","mean")

# create ggplot2 plot
ggplot(datamat) + 
  geom_histogram(mapping=aes(x=mean,group=samplesize),bins=50,col="red",fill="red") +  theme(text = element_text(size = 15))+theme(plot.title = element_text(hjust = 0.5),plot.subtitle=element_text(hjust=0.5))+
  ggtitle("Distribution of Observed Mean values") +
  labs(subtitle=("Sample Size : {closest_state}")) +
  ylab("Absolute Frequency out of 1000") + 
  xlab("Observed Mean Value ") + 
  transition_states(samplesize)
#anim_save("gammean.gif")
```


A few questions for you:


- What shape does it look like? 
- What do we notice when the sample size increases? 
- What factor do you think will affect the the spread?


The theory behind this will be introduced below.


**Then we put the app here and have them consider different values of $\alpha$, $\lambda$, and $n$ with guidance for trying to find some 'rule' for when the normal distribution might be appropriate.**

```{r, echo=FALSE, eval = FALSE}
sidebarPanel( sliderInput("d_ngam",
                                    "n: sample size",
                                    min = 1,
                                    max = 2000,
                                    step=30,
                                    value = 50,
                                  animate=animationOptions(
                                  interval = 1000,
                                  loop = TRUE,
                                  playButton = "Play",
                                  pauseButton = "Stop")) ,
                                     helpText("As \\(n\\) increases,"),
                        helpText("\\(\\star\\) The mean of gamma distribution approaches to normal"),
                       
                    
                        sliderInput("alpha",
                                    "alpha: shape parameter",
                                    min = 0.1,
                                    max = 50,
                                    step=5,
                                    value = 0.1,
                                  animate=animationOptions(
                                  interval = 5,
                                  loop = TRUE,
                                  playButton = "Play",
                                  pauseButton = "Stop")) ,
                                                   helpText("As \\(alpha\\) increases,"),
                        helpText("\\(\\star\\) The mean of the gamma distribution increases"),
                sliderInput("lambda",
                                    "lambda: scale parameter",
                                    min = 0.1,
                                    max = 50,
                                    step=5,
                                    value = 0.1,
                                  animate=animationOptions(
                                  interval = 5,
                                  loop = TRUE,
                                  playButton = "Play",
                                  pauseButton = "Stop")) ,
               helpText("As \\(lambda\\) increases,"),
                        helpText("\\(\\star\\) The distribution of the mean is more spread out"))
                      
                        
                 

############

mainPanel(
                          helpText(h4('Let \\(Y_1, Y_2,....,Y_n\\) be independent random variables \\(Y\\sim gam(alpha,lambda)\\), \\( (\\bar Y)=\\sim N(alpha*lambda,\\frac{alpha*lambda^2}{n})\\).')),
                      
                      
   renderPlot({
      set.seed(1)

  d_ngam=input$d_ngam
      d_alpha=input$alpha
       d_lamda=input$lambda
       
       M=2000 #number of repetitions
        gamsample=c(0)
      for (i in 1:M){
      gamsample[i]=mean(rgamma(n = d_ngam, shape = alpha, scale = lambda) )}
      
        datamatgam=data.frame(cbind(rep(d_ngam,M),c(gamsample)))
        colnames(datamatgam)=c("samplesize","mean")

# create ggplot2 plot
ggplot(datamatgam) + 
  geom_histogram(mapping=aes(x=mean,group=samplesize),bins=50,col="red",fill="red") +  theme(text = element_text(size = 15))+theme(plot.title = element_text(hjust = 0.5),plot.subtitle=element_text(hjust=0.5))+
  ggtitle("Distribution of Observed Mean values") +
  labs(subtitle=(paste0("Sample Size :",d_ngam))) +
  ylab("Absolute Frequency out of 1000") + 
  xlab("Observed Mean Value ") 
      
    })
  )             
```


<div class = "clearfix"> </div>

<button type="button" class="collapsible">Key for a reliable Mean Estimate</button>
<div class="content">

**Large sample size

</div>
<div class = "clearfix"> </div>



## Why do we care about limit theory? 

Ideally as our sample size grows the statistics we are using will **converge** to their *true* values, often a parameter they are estimating, in some sense. For instance, we hope that the sample mean gets closer and closer to the population mean we are interested in. 

The convergence of random variables is important for asymptotic inference. As we can never collect infinity number of data, asymptotic result is critical to approximate the distribution of statistics of interest with finite sample size. We will discuss the most common three types of convergence.

Just for proof of concept. Notation:
<button type="button" class="collapsible">Open Collapsible</button>
<div class="content">
  * Let $X_1,X_2,\cdots,X_n$ be a sequence of iid random variables and $X$ be a random variable such that $E(X_i)=\mu, Var(X_i)=\sigma^2 < \infty, \forall i$
  * Convergence in distirbution $X_n\stackrel{d}{\rightarrow} X$
  * Convergence in probability $X_n\stackrel{p}{\rightarrow} X$
  * Convergence almost surely $X_n\stackrel{a.s.}{\rightarrow} X$
</div>


## Convergence in Distribution
* Definition $lim_{n \rightarrow \infty} F_{X_n}(x)=F_{X}(x)$, or
            $lim_{n \rightarrow \infty} |F_{X_n}(x)-F_{X}(x)|=0$
  * $F_X(x)$ is continuous
  * Cumulative Density Function (CDF)

Below is the empirical cumulative distribution for binomial distribution and the appropriate normal distribution. We investigate the distribution of the sample means from the binomial distribution out of 1000 repetitions.

<div class = "clearfix"> </div>
  
:::: {style="display: flex;"}

::: {}


```{r, echo=FALSE,message=FALSE, eval = FALSE}
#ggplot(datamat[datamat$samplesize==500,], aes(mean)) +                      # Draw cumulative ggplot2 histogram
  #stat_ecdf(geom = "step", pad = FALSE)
p=0.6
n=100
NN=1000
n500cdf=rbinom(NN,n,p)

ecdf <- data.frame(
  x = c(n500cdf, rnorm(NN, n*p, sqrt(n*p*(1-p)))),
   CDF= c(rep("Binormial (100,0.6)",NN), rep("Normal (60, 24)",NN))
)
ggplot(ecdf, aes(x,color=CDF)) +stat_ecdf()+
  theme(text = element_text(size = 15))+theme(plot.title = element_text(hjust = 0.5))+theme(legend.text = element_text(size=15))+ theme(legend.position = c(0.8, 0.1))+
  ggtitle("Emprical Cumulative Distribution Function") +
  ylab("Cumulative Distribution Function") + 
  xlab("Observed Mean Value ")

#![](/Users/xzhao17/Desktop/empirical1.png) 
```




:::

::: {}


```{r, echo=FALSE,message=FALSE, eval = FALSE}
MM=1000 #number of simulation
n500cdfmean=c(0)
for (i in 1:MM){
  n500cdfmean[i]=mean(rbinom(NN,n,p))
}
n500df=data.frame(n500cdfmean)
ggplot(n500df,aes(x=n500cdfmean)) +
     geom_histogram(aes(y = ..density..),col="red",fill="green") + geom_density(alpha=.2)+ theme(text = element_text(size = 15))+theme(plot.title = element_text(hjust = 0.5),plot.subtitle=element_text(hjust=0.5))+
     ggtitle("Distribution of Observed Mean values") +
     ylab("Absolute Frequency out of 1000") + 
     xlab("Observed Mean Value ") 
```
:::




```{r, include=FALSE, eval = FALSE}
#From 501 notes
#Simulate N data sets, each of size n, from an exp(1) distribution
n <- c(3, 30, 300)
N <- 50000

#list to save data values in (this is not an efficient way to create this data!)
data <- list()
for(i in 1:length(n)){ 	
    data[[i]] <- matrix(0, nrow = N, ncol = n[i])  #each row of a matrix will represent a data set
}

#Create the data - loop over sample sizes
for (j in 1:length(n)){	#loop over sample sizes
     for (i in 1:N){  #loop to create many data sets of a given sample size
           data[[j]][i,] <- rexp(n = n[j])	#store the data set in a row of the appropriate matrix
     }
}
#mean and variance for exp(1)
mu<-sigma<-1

#calculate the z statistic for each set of samples.  Apply the z-score transform to each row of values.
means1 <- apply(X = data[[1]], FUN = function(data){(mean(data)-mu)/(sigma/sqrt(n[1]))}, MARGIN = 1)
hist(means1, main = paste("Histogram of z's with n=", n[1], " from exp(1)", sep = ""), 
      xlab = "Means", prob = T)
lines(seq(from = -3, to = 3, by = 0.01), dnorm(seq(from = -3, to = 3, by = 0.01)))
 #Repeat this part for n = 30, n = 300
```


::::


:::


<div class = "clearfix"> </div>

## Central Limit Theorem
Define $\overline{X}=\frac{1}{n} \sum_{i=1}^{n} X_i$ such that $E(X_i)=\mu, Var(X_i)=\sigma^2 < \infty, \forall i$ and $X \sim N (0, 1)$

* $\frac{\sqrt{n} (\overline{X_n}-\mu)}{\sigma} \stackrel {d} {\rightarrow} X$


```{r, echo=FALSE,message=FALSE,include=FALSE, eval = FALSE}
#this is using gamma example-discussed to just use binomial to be consistent, histogram of mean and density plot

ggplot(datamat[datamat$samplesize==500,],aes(x=mean)) +
     geom_histogram(aes(y = ..density..),col="red",fill="green") + geom_density()+ theme(text = element_text(size = 15))+theme(plot.title = element_text(hjust = 0.5),plot.subtitle=element_text(hjust=0.5))+
     ggtitle("Distribution of Observed Mean values") +
     ylab("Absolute Frequency out of 1000") + 
     xlab("Observed Mean Value ") 
```



<div class = "clearfix"> </div>

##CLT Applied to a Sum 

$$\sum_{i=1}^{n} Y_i \stackrel{\bullet}{\sim}N(n\mu, n\sigma^2)$$

-Example: $Y_1,...,Y_{n}\stackrel{iid}{\sim}f_Y(y)=2y$ if $0<y<1$ (0 O.W.).  
Note: $E(Y)=2/3$ and $Var(Y)=1/18$.\\
Let $S=Y_1+...+Y_n$, can we approximate $P(S\leq 10)$?

Practically, why is the CLT so important?

- Suppose we know $\sigma$ and we want inference for $\mu$.
- If we get a RS $Y_1,...,Y_n$ we know 
	$\bar{Y}\stackrel{\bullet}{\sim}N(\mu,\sigma^2/n)$ ($\mu$ only unknown)
- We can make an approximate claim about $\mu$ via a confidence interval
	$$P(-1.96<Z<1.96)=0.95 \Leftrightarrow 
	P\left(-1.96<\frac{\bar{Y}-\mu}{\sigma/\sqrt{n}}<1.96\right)=0.95$$
	$$\Leftrightarrow 
	P\left(\bar{Y}-1.96\sigma/\sqrt{n}<\mu<\bar{Y}+1.96\sigma/\sqrt{n}\right)=0.95$$
	- That is, there is a 95\% probability the RVs 
	$\bar{Y}-1.96\sigma/\sqrt{n}$ and $\bar{Y}+1.96\sigma/\sqrt{n}$ capture 
	$\mu$.
	- Observe $\bar{Y}=\bar{y}$, get observed CI.  Range we are `confident' 
	contains $\mu$.
	- Note: No assumption about $Y$'s distribution made other than finite 
	variance!
:::

::::
<div class = "clearfix"> </div>


##CLT Applied to a Sum 

$$\sum_{i=1}^{n} Y_i \stackrel{\bullet}{\sim}N(n\mu, n\sigma^2)$$

-Example: $Y_1,...,Y_{n}\stackrel{iid}{\sim}f_Y(y)=2y$ if $0<y<1$ (0 O.W.).  
Note: $E(Y)=2/3$ and $Var(Y)=1/18$.\\
Let $S=Y_1+...+Y_n$, can we approximate $P(S\leq 10)$?

Practically, why is the CLT so important?

- Suppose we know $\sigma$ and we want inference for $\mu$.
- If we get a RS $Y_1,...,Y_n$ we know 
	$\bar{Y}\stackrel{\bullet}{\sim}N(\mu,\sigma^2/n)$ ($\mu$ only unknown)
- We can make an approximate claim about $\mu$ via a confidence interval
	$$P(-1.96<Z<1.96)=0.95 \Leftrightarrow 
	P\left(-1.96<\frac{\bar{Y}-\mu}{\sigma/\sqrt{n}}<1.96\right)=0.95$$
	$$\Leftrightarrow 
	P\left(\bar{Y}-1.96\sigma/\sqrt{n}<\mu<\bar{Y}+1.96\sigma/\sqrt{n}\right)=0.95$$
	- That is, there is a 95\% probability the RVs 
	$\bar{Y}-1.96\sigma/\sqrt{n}$ and $\bar{Y}+1.96\sigma/\sqrt{n}$ capture 
	$\mu$.
	- Observe $\bar{Y}=\bar{y}$, get observed CI.  Range we are `confident' 
	contains $\mu$.
	- Note: No assumption about $Y$'s distribution made other than finite 
	variance!



<div class = "clearfix"> </div>




## R shiny demonstration by the instructor

### This section illustrates convergence in distribution

#### "\\(\\star\\)By definition, \\(X_n \\overset{d} {\\to} X\\) or \\(X_n \\overset{L} {\\to} X\\) if and only if \\(l_n= \\lvert F_{X_n}(t)-F_X(t) \\rvert \\underset{n\\to \\infty} \\rightarrow  0\\) for all \\(t\\) and \\(F_X(x)\\) is continuous. "

#### "\\(\\star\\) \\(\\widehat l_n(t)=\\lvert \\widehat F_{X_n}(t)-F_X(t) \\rvert\\) is used for convergence in distribution. \\(F_X(t)\\) is the cumulative distribution function of \\(X\\) and \\(\\widehat F_{X_n} (t)\\) is the empirical distribution function of \\(X_n\\) such that  \\(\\widehat F_{X_n} (t)=\\frac{\\# \\{x_n^{j} \\leq t \\}}{M}, \forall j =1,\\cdots, M\\)."

<div class = "clearfix"> </div>

```{r, include=FALSE}
#hist(rbeta(1000 , 10000, 10000)) #beta (bigalpha,bigalpha) normal (1/2,sqrt(1/4(2bigalpha+1)))
```




```{r, include=FALSE}
#hist(rpois(1000, lambda=1000)). #poisson (biglamda) normal(biglamda, biglamda)
```


We want to explore the distribution convergence in distribution and central limit theorem through the interactive app. Before we jump into shiny, let's introduce some parameters which can be varied. We will still use the binomial distribution example we visualized earlier.

*n: The number of the sample size. With everything else fixed, as $n\rightarrow \infty$:
    *Histogram: it becomes a symmetric bell-shape
    *CDF:
    *3D distance between ECDF and Normal CDF:
    *Sample path
```{r,echo=FALSE,message=FALSE, eval = FALSE}
#histogram by sample size
n20b=c(0)
for (i in 1:M){
  n20b[i]=rbinom(NN,20,p)
}
n50b=c(0)
for (i in 1:M){
  n50b[i]=rbinom(NN,50,p)
}

n100b=c(0)
for (i in 1:M){
  n100b[i]=rbinom(NN,100,p)
}
n500b=c(0)
for (i in 1:M){
  n500b[i]=rbinom(NN,500,p)
}
datamatb=data.frame(cbind(c(rep(c(20,50,100,500),each=M)),c(n20b,n50b,n100b,n500b)))
colnames(datamatb)=c("samplesize","Value")

# create ggplot2 plot
ggplot(datamatb) + 
  geom_histogram(mapping=aes(x=Value,group=samplesize),bins=50,col="red",fill="red")  +  theme(text = element_text(size = 15))+theme(plot.title = element_text(hjust = 0.5),plot.subtitle=element_text(hjust=0.5))+
  ggtitle("Histogram of Observed Values") +
  labs(subtitle=("Sample Size : {closest_state}")) +
  ylab("Absolute Frequency out of 1000") + 
  xlab("Observed Value ") + 
  transition_states(samplesize)
```



```{r,echo=FALSE,message=FALSE, eval = FALSE}
#CDF by sample size
library(EnvStats)
library(transformr)

##n=20
 n20=rbinom(NN,20,p)
 n20norm=rnorm(NN, 20*p, sqrt(20*p*(1-p)))
 # xx20 <- qemp(p = seq(0, 1, len = 100), obs = n20) 
 # y20 <- cumsum(demp(xx20, n20) )
 #y20 <- ecdf( n20)
 
 y20=cumsum(density(n20,n=NN)$y)
 #repn=length(density(n20)$y)
 # 
 # xx20n <- qemp(p = seq(0, 1, len = 100), obs = n20norm) 
 #y20n <- ecdf( n20norm)
 
 
 ##CDF= c(rep("Binormial (20,0.6)",NN), rep("Normal (12, 4.8)",NN)). x=c(n20,n20norm)
 y20n <- cumsum(density(n20norm,n=NN)$y)
ecdf20 <- data.frame(
   x=c(n20,n20norm),
   y = c(y20, y20n),
  
   
   CDF= c(rep("Binormial (20,0.6)",NN), rep("Normal (12, 4.8)",NN))
)

##n=50
 n50=rbinom(NN,50,p)
 n50norm=rnorm(NN, 50*p, sqrt(50*p*(1-p)))
 #xx50 <- qemp(p = seq(0, 1, len = 100), obs = n50) 
 #y50 <- ecdf(n50 )
 y50=cumsum(density(n50,n=NN)$y)
 
 #xx50n <- qemp(p = seq(0, 1, len = 100), obs = n50norm) 
 #y50n <- ecdf(n50norm)
 
 y50n <- cumsum(density(n50norm,n=NN)$y)
ecdf50 <- data.frame(
   x=c(n50,n50norm),
   y = c(y50, y50n),
  
   CDF= c(rep("Binormial (50,0.6)",NN), rep("Normal (30, 12)",NN))
)

##n=100
 n100=rbinom(NN,100,p)
 n100norm=rnorm(NN, 100*p, sqrt(100*p*(1-p)))
 #xx100 <- qemp(p = seq(0, 1, len = 100), obs = n100) 
 #y100 <- ecdf(n100 )
 y100=cumsum(density(n100,n=NN)$y)
 
 #xx100n <- qemp(p = seq(0, 1, len = 100), obs = n100norm) 
# y100n <- ecdf(n100norm)
 y100n <- cumsum(density(n100norm,n=NN)$y)
ecdf100 <- data.frame(
   x=c(n100,n100norm),
   y = c(y100, y100n),
  
   CDF= c(rep("Binormial (100,0.6)",NN), rep("Normal (60, 24)",NN))
)

##n=500
 n500=rbinom(NN,500,p)
 n500norm=rnorm(NN, 500*p, sqrt(500*p*(1-p)))
 #xx500 <- qemp(p = seq(0, 1, len = 100), obs = n500) 
 #y500 <- ecdf( n500) 
  y500=cumsum(density(n500,n=NN)$y)
 
 #xx500n <- qemp(p = seq(0, 1, len = 100), obs = n500norm) 
 #y500n <- ecdf( n500norm)
 y500n <- cumsum(density(n500norm,n=NN)$y)
ecdf500 <- data.frame(
   x=c(n500,n500norm),
   y = c(y500, y500n),
  
   CDF= c(rep("Binormial (500,0.6)",NN), rep("Normal (300, 120)",NN))
)


ecdfall=rbind(ecdf20,ecdf50,ecdf100,ecdf500)
ecdfall$samplesize=rep(c(20,50,100,500),each=2*NN)

#+stat_ecdf() +stat_ecdf(aes(color=CDF))+
#color=CDF,
ggplot(ecdfall, aes(x,group=samplesize,color=CDF)) +stat_ecdf()+
  theme(text = element_text(size = 15))+theme(plot.title = element_text(hjust = 0.5),plot.subtitle=element_text(hjust=0.5))+theme(legend.text = element_text(size=15))+ theme(legend.position = c(0.8, 0.1))+
  ggtitle("Emprical Cumulative Distribution Function") + labs(subtitle=("Sample Size : {closest_state}"))+
  ylab("Cumulative Distribution Function") + 
  xlab("Observed Value ")+transition_states(samplesize)

```




```{r,echo=FALSE,message=FALSE, eval = FALSE}
#3D plot by sample size
library(EnvStats)
library(transformr)
library(viridis)
library(ggridges)

# ggplot(lincoln_weather, aes(x = `Mean Temperature [F]`, y = Month, fill = stat(x))) +
#   geom_density_ridges_gradient(scale = 3, rel_min_height = 0.01) +
#   scale_fill_viridis_c(name = "Temp. [F]", option = "C") +
#   labs(title = 'Temperatures in Lincoln NE in 2016')

#+stat_ecdf()
#color=CDF,

yall=c(y20,y50,y100,y500)
yalln=c(y20n,y50n,y100n,y500n)
yd=data.frame(cbind(yall,yalln))
colnames(yd)=c("yall","yalln")
yd$samplesize=rep(c(20,50,100,500),each=NN)

#ggplot(iris, aes(x = Sepal.Length, y = Species)) + geom_density_ridges(scale = 0.9)


ggplot(yd, aes(x=yalln-yall,y=samplesize,fill=stat(x),group=samplesize)) +geom_density_ridges_gradient(scale = 3, rel_min_height = 0.01)+
  theme(text = element_text(size = 15))+theme(plot.title = element_text(hjust = 0.5),plot.subtitle=element_text(hjust=0.5))+theme(legend.text = element_text(size=15))+ theme(legend.position = c(0.9, 0.8))+scale_fill_viridis_c(name = "Differences", option = "C")+
  ggtitle("Distance Between binormial ECDF and normal CDF ") + 
  ylab("Sample Size") + 
  xlab("Observed Differences ")

```



```{r ,echo=FALSE,message=FALSE, eval = FALSE}
library(tidyverse)
library(plotly)

#https://stackoverflow.com/questions/72590265/3d-plot-of-monthly-temperature-in-r
# temp %>% 
#   pivot_longer(starts_with('Hour'), 
#                names_to = 'Hour',
#                values_to = 'Temperature') %>%
#   group_by(Year, Month) %>%
#   summarise(Temperature = mean(Temperature, na.rm = TRUE)) %>%
#   pivot_wider(names_from = Month, values_from = Temperature) %>%
#   ungroup() %>%
#   select(-1) %>%
#   as.matrix() %>%
#   plot_ly(x = month.name, y = unique(temp$Year), z = .) %>%
#   add_surface()
yd$obs=rep(c(1:1000),4)
yd$ydiff=yd$yall-yd$yalln
ydsub=yd[,c(3,4,5)]
 ydsub%>% 
  group_by(ydsub$samplesize, ydsub$obs) %>%
  ungroup() %>%
  #select(-1) %>%
  as.matrix() %>%
  plot_ly(x = ydsub$obs, y = unique(ydsub$samplesize), z = .) %>%
  add_surface()
```





*Other distribution specific parameters:
 *$\alpha$: shape parameter for gamma distribution. 
  As $\alpha\rightarrow \infty$, gamma distribution converges to normal distribution.
 *$\lambda$: rate parameter for poisson distribution. 
  As $\lambda\rightarrow \infty$, poisson distribution converges to normal distribution
 *$\alpha,\beta$: rate parameters for beta distribution. 
  As $\alpha=\beta\rightarrow \infty$, beta distribution converges to normal distribution

```{r  echo=FALSE, eval = FALSE}
law.plot3dnew=function (data, probfunc, tinf = -5, tsup = 5) 
{
    nmax <- ncol(data)
    Fhat <- function(x) {
        n <- x[1]
        t <- x[2]
        Fn <- ecdf(data[, n])
        Fn(t)
    }
    g <- expand.grid(t = seq(from = tinf, to = tsup, length = 10), 
        n = 1:nmax)
    Mymat <- g[, 2:1]
    g$z <- abs(apply(Mymat, FUN = Fhat, MARGIN = 1) - probfunc(g$t))
    print(wireframe(z ~ t + n, data = g, scales = list(arrows = FALSE), 
        drape = TRUE, colorkey = TRUE, screen = list(z = -50, 
            x = -70), zlab = list(expression(hat(l)[n] ~ "(x)=|" ~ 
            hat(F)[n] ~ "(x)-" ~ F ~ "(x)|"), rot = 90), main = "Convergence in Distribution?", xlab="x"))
}
sidebarPanel(#d_n=1000,
#########

                      #selectInput("tabs",
                                  #"Distribution",
                                  #list('Binormial','Beta','Poisson'),multiple = FALSE),

                     # selectInput("tabs",
                                 # "Distribution",
                                 # list('Binormial','Beta','Poisson'),multiple = FALSE

  # inputId,
  # label,
  # choices,
  # selected = NULL,
  # multiple = FALSE,
  # selectize = TRUE,
  # width = NULL,
  # size = NULL

#),

                    
                        # sliderInput("d_ns",
                        #             "M: the number of simulations of the sequence",
                        #             min = 1,
                        #             max = 2000,
                        #             step=30,
                        #             value = 50,
                        #           animate=animationOptions(
                        #           interval = 1000,
                        #           loop = TRUE,
                        #           playButton = "Play",
                        #           pauseButton = "Stop")) ,
                        # 
                        # 
                        # helpText("As \\(M\\) increases,"),
                        # helpText("\\(\\star\\) The 3-D plot of \\(\\widehat l_n(t)=\\lvert \\widehat F_{X_n}(t)-F_X(t) \\rvert\\) will get closer to zero horizontal plane"),
                        # helpText("\\(\\star\\)  \\(X_n \\overset{d} {\\to} X\\sim N(0,1)\\)"),
             #d_ns=1000,           
      #####
                    
                          sliderInput("d_k",
                                      #helpText("\\(K\\)=position of \\(X_n\\) and \\(K\\leq n_{max}\\)"),
                                      helpText("\\(n\\)=Sample Size of \\(X_n\\)"),
                                      min = 1,
                                      max = 1000,
                                      step=1,
                                      value = 10,
                                  animate=animationOptions(
                                  interval = 1000,
                                  loop = TRUE,
                                  playButton = "Play",
                                  pauseButton = "Stop")),
                          helpText("As \\(n\\) increases,"),
                          helpText("\\(\\star\\) Density plot of \\(X_n\\) values will resemble a standard normal curve"),
                          helpText("\\(\\star\\) \\(\\widehat F_{X_n}(t)\\) will approach to \\(F_X(t)\\) ") )
       

############

mainPanel(
                          helpText(h4('Let \\(Y_1, Y_2,....,Y_n\\) be independent random variables \\(Y\\sim \\chi_1^2\\), \\(Xn=\\frac {\\sum Y_i-n}{\\sqrt{2*n}} \\) and \\(X\\sim N(0,1)\\).')),
                      
                      helpText(h4("\\(F_{X_n}(t)\\) is the empirical distribution of \\(X_n\\) and \\(F_X(t)\\) is cdf of \\(X\\). We use \\(\\widehat F_{X_n} (t)\\) to approximate \\(F_{X_n}(t)\\). ")),
                      
            
      tabsetPanel(id = "Binormial",
        tabPanel("Histogram and CDF", splitLayout(

renderPlot({
      set.seed(1)
      #d_n=input$d_n
     #d_n=1000
      #d_ns=input$d_ns
       d_ns=1000
      d_k=input$d_k
      d_n=input$d_k
      d_f=function(d_n){(cumsum(rchisq(d_n,df=1))-(1:d_n))/sqrt(2*(1:d_n))}
      d_data=data.frame()
      for (s in 1:d_ns){
        d_data=rbind(d_data,d_f(d_n))
      }
      d_h=hist(data.matrix(d_data[d_k]),main=mtext(bquote(bold("Density plot of"~X[n]~"values")),col="darkblue"),xlab="Xn values",col="green",border = "red",prob = T, xlim = c(-4,4))
     
      lines(seq(-4,4,length=d_ns),dnorm(seq(-4,4,length=d_ns)),col="darkblue",lwd=3)
      
      legend('topleft', c(expression(hat(f[X[n]](t))),expression(f[X](t))),
             fill =c("green", "darkblue"))
      
      text(x=4,y=max(d_h$density),bquote(bold(f[X[n]](t)~"will resemble"~f[X](t))),col="red",adj=1)
    }),
#d_hist
#######
  renderPlot({
      set.seed(1)

      #d_n=input$d_n
       d_n=input$d_k
      #d_ns=input$d_ns
      d_ns=1000
      d_k=input$d_k
      d_f=function(d_n){(cumsum(rchisq(d_n,df=1))-(1:d_n))/sqrt(2*(1:d_n))}
      d_data=data.frame()
      for (s in 1:d_ns){
        d_data=rbind(d_data,d_f(d_n))
      }
      d_h=hist(data.matrix(d_data[d_k]),main=mtext(bquote(bold(.(d_ns)~"sample paths of"~X[n]~"values")),col="darkblue"),xlab="Xn values",col="green",border = "red",xlim = c(-4,4),prob=T,breaks = d_ns)

      d_y=d_h$density
      d_x=seq(-4,4,length.out =length(d_y))

      plot(d_x,cumsum(d_y)/max(cumsum(d_y)),type="l",lwd=2,main=mtext(bquote(bold(hat(F[X[n]](t))~"and"~F[X](t))),col="darkblue"),col="green",xlim=c(-4,4),xlab = "X", ylab = "Cumulative probability" )
      lines(d_x,pnorm(d_x),col="darkblue")
      legend('topleft', c(expression(hat(F[X[n]](t))),expression(F[X](t))),lty = c(1,1),col = c("green", "darkblue") )
             #fill =c("green", "darkblue"))

      text(x=4,y=0.05,bquote(bold(F[X[n]](t)~"will resemble"~F[X](t))),col="red",adj=1)
    })
###########
)),
        tabPanel("3D Distance",  renderPlot({
      set.seed(1)
      #d_n=input$d_n
  d_n=input$d_k
      #d_ns=input$d_ns
        d_ns=1000
      d_f=function(d_n){(cumsum(rchisq(d_n,df=1))-(1:d_n))/sqrt(2*(1:d_n))}
        d_data_3D <- generate(randomgen=d_f,nmax=d_n,M=d_ns)$data
        law.plot3dnew(d_data_3D,pnorm)
    })),
        tabPanel("Sample Path", renderPlot({
      set.seed(1)
      #d_n=input$d_n
        d_n=input$d_k
      #d_ns=input$d_ns
      d_ns=1000
        #eps2=input$ep2
      d_f=function(d_n){(cumsum(rchisq(d_n,df=1))-(1:d_n))/sqrt(2*(1:d_n))}
      d_data_3D <- generate(randomgen=d_f,nmax=d_n,M=d_ns)$data
        visualize.sp(d_data_3D,nb.sp=d_ns,epsilon=3,main=mtext(bquote(bold(.(d_ns)~"sample paths of"~X[n]~"values")),col="darkblue"), col="grey")
    }))
      )
             
                  
   


)             
     
 

```

<div class = "clearfix"> </div>
## Your Turn

```{r  echo=FALSE, eval = FALSE}

#gamma(r,lambda), mu=rlambda,var=rlambda^2, as r goes to infinity, it goesto normal
sidebarPanel(
   selectInput("tabs",
                                  "Distribution",
                                  list('Binormial','Beta','Poisson'),multiple = FALSE),
  
  #clt_n=1000,
# sliderInput("clt_n",
                                  # "n: the nth element in the sequence",
                                  # min = 10,
                                  # max = 1000,
                                  # step=5,
                                  # value = 100,
                                  # animate=animationOptions(
                                  # interval = 1000,
                                  # loop = TRUE,
                                  # playButton = "Play",
                                  # pauseButton = "Stop")),
                      
                      
                      
                      # helpText("As \\(n\\) increases,"),
                      # helpText("\\(\\star\\) More points will be created in each sample path and the density plot will vary"),
                      # 
####
# sliderInput("clt_ns",
#                                     "M: the number of simulations of the sequence",
#                                     min = 1,
#                                     max = 2000,
#                                     step=5,
#                                     value = 50,
#                                   animate=animationOptions(
#                                   interval = 1000,
#                                   loop = TRUE,
#                                   playButton = "Play",
#                                   pauseButton = "Stop")),
                      #clt_ns=1000,
                      # helpText("As \\(M\\) increases,"),
                      # helpText("\\(\\star\\) The 3-D plot of \\(\\widehat l_n(t)=\\lvert \\widehat F_{X_n}(t)-F_X(t) \\rvert\\) will get closer to zero horizontal plane"),
                      # helpText("\\(\\star\\)  \\(X_n \\overset{d} {\\to} X\\sim N(0,1)\\)"),
############
sliderInput("clt_k",
                                     # helpText("\\(K\\)=position of \\(X_n\\) and \\(K\\leq n_{max}\\)"),
             helpText("\\(n\\): sample size of \\(X_n\\) "),
                                      min = 1,
                                      max = 1000,
                                      step=1,
                                      value = 10,
                                  animate=animationOptions(
                                  interval = 1000,
                                  loop = TRUE,
                                  playButton = "Play",
                                  pauseButton = "Stop")),
                          helpText("As \\(n\\) increases,"),
                          helpText("\\(\\star\\) Density plot of \\(X_n\\) values will resemble a standard normal curve"),
                          helpText("\\(\\star\\) \\(\\widehat F_{Xn}(t)\\) will approach to \\(F_X(t)\\)"),
#####
sliderInput("clt_alpha",
                                    helpText("\\(\\alpha\\)=shape parameter"),
                                    min = 1,
                                    max = 1000,
                                    step=5,
                                    value = 50,
                                  animate=animationOptions(
                                  interval = 1000,
                                  loop = TRUE,
                                  playButton = "Play",
                                  pauseButton = "Stop")),
                    
                      
                      helpText("\\(\\star\\) As \\(\\alpha\\) increases, the histogram will be more symmetric "),
#######
#clt_beta=1,
 sliderInput("clt_beta",
                                    helpText("\\(\\beta\\)=scale parameter"),
                                    min = 0.0001,
                                    max = 10,
                                     step=0.1,
                                     value = 1,
                                   animate=animationOptions(
                                  interval = 1000,
                                   loop = TRUE,
                                   playButton = "Play",
                                  pauseButton = "Stop")),
                        #helpText("\\(\\star\\) As \\(\\beta\\) increases, the histogram will spread out more  ")
 )
#######
mainPanel(
helpText(h4("This app is designed to visualize \\(X_n=\\frac{\\sqrt{n} ( \\overline Y_i-\\mu)  )}{\\sigma} \\overset {d}{\\to} X\\sim N(0,1) \\; or\\; X_n=\\frac{\\sqrt{n} ( \\overline Y_i-\\mu)  )}{\\sigma} \\overset {L}{\\to} X\\sim N(0,1) \\).")),
                      helpText(h4('Let \\(Y_1, Y_2,....,Y_n\\) be independent random variables \\(Y\\sim Gamma(\\alpha,\\beta)\\) and \\(Xn=\\frac{\\sqrt{n}*(\\overline Y_i-\\alpha*\\beta)}{\\sqrt{\\alpha*\\beta^2}}\\).')),
                      helpText(h4("\\(F_{X_n}(t)\\) is the empirical distribution of \\(X_n\\) and \\(F_X(t)\\) is cdf of \\(X\\). We use \\(\\widehat F_{X_n} (t)\\) to approximate \\(F_{X_n}(t)\\).  ")),



      tabsetPanel(id = "tabs",
        tabPanel("Histogram and CDF", splitLayout(
  #clt_hist <- renderPlot({
    renderPlot({
      set.seed(1)
        #clt_n=input$clt_n
        clt_n=input$clt_k
        #clt_ns=input$clt_ns
        clt_ns=1000
        clt_alpha=input$clt_alpha
        #clt_beta=1
        clt_beta=input$clt_beta
        clt_k=input$clt_k
        clt_f=function(clt_n){sqrt(1:clt_n)*(cumsum(rgamma(clt_n,shape=clt_alpha,scale=clt_beta))/(1:clt_n)-clt_alpha*clt_beta)/sqrt(clt_alpha*(clt_beta**2))}
        
        clt_data=data.frame()
        
        for (t in 1:clt_ns){
          clt_data=rbind(clt_data,clt_f(clt_n))
        }
        clt_h=hist(data.matrix(clt_data[clt_k]),main=mtext(bquote(bold("Density plot of"~X[n]~"values")),col="darkblue"),xlab="Xn values",col="green",border = "red",xlim = c(-4,4),prob=T)
        
        lines(seq(-4,4,length=length(clt_h$density)),dnorm(seq(-4,4,length=length(clt_h$density))),col="darkblue",lwd=3)
        
        legend('topleft', c(expression(hat(f[X[n]](t))),expression(f[X](t))),
               fill =c("green", "darkblue"))
        
        text(x=4,y=max(clt_h$density),bquote(bold(f[X[n]](t)~"will resemble"~f[X](t))),col="red",adj=1)
        
        
        }),
      renderPlot({ 
      set.seed(1)
      #clt_n=input$clt_n
      clt_n=input$clt_k
      #clt_ns=input$clt_ns
      clt_ns=1000
      clt_alpha=input$clt_alpha
      #clt_beta=1
      clt_beta=input$clt_beta
      clt_k=input$clt_k
      clt_f=function(clt_n){sqrt(1:clt_n)*(cumsum(rgamma(clt_n,shape=clt_alpha,scale=clt_beta))/(1:clt_n)-clt_alpha*clt_beta)/sqrt(clt_alpha*(clt_beta**2))}
      
      clt_data=data.frame()
      
      for (t in 1:clt_ns){
        clt_data=rbind(clt_data,clt_f(clt_n))
      }
      clt_h=hist(data.matrix(clt_data[clt_k]),main=mtext(bquote(bold("Density plot of"~X[n]~"values")),col="darkblue"),xlab="Xn values",col="green",border = "red",xlim = c(-4,4),prob=T,breaks = clt_ns)
      clt_y=clt_h$density
      clt_x=seq(-4,4,length=length(clt_y))
      
      plot(clt_x,cumsum(clt_y)/max(cumsum(clt_y)),type="l",lwd=2,col="green",main=mtext(bquote(bold(hat(F[X[n]](t))~"and"~F[X](t))),col="darkblue"), xlim=c(-4,4),xlab = "X", ylab = "Cumulative probability")
      lines(clt_x,pnorm(clt_x),col="darkblue")
      legend('topleft', c(expression(hat(F[X[n]](t))),expression(F[X](t))),lty = c(1,1),col = c("green", "darkblue") )
            # fill =c("green", "darkblue"))
      
      text(x=4,y=0.1,bquote(bold(F[X[n]](t)~"will resemble"~F[X](t))),col="red",adj=1)
    })
                      #clt_hist
   
#clt_3D
  
)),
        tabPanel("3D Distance",   #clt_3D <- renderPlot({
       renderPlot({
      set.seed(1)
      clt_n=input$clt_k
      #clt_n=input$clt_n
      #clt_ns=input$clt_ns
      clt_ns=1000
      clt_alpha=input$clt_alpha
      clt_beta=input$clt_beta
      #clt_beta=1
      clt_f=function(clt_n){sqrt(1:clt_n)*(cumsum(rgamma(clt_n,shape=clt_alpha,scale=clt_beta))/(1:clt_n)-clt_alpha*clt_beta)/sqrt(clt_alpha*(clt_beta**2))}
      
      clt_data_3D=data.frame()
      for (t in 1:clt_ns){
        clt_data_3D=rbind(clt_data_3D,clt_f(clt_n))
      }
      law.plot3dnew(data.matrix(clt_data_3D),pnorm)
    })),
        tabPanel("Sample Path", renderPlot({
      set.seed(1)
      clt_n=input$clt_k
      #clt_n=input$clt_n
      #clt_ns=input$clt_ns
      clt_ns=1000
      clt_alpha=input$clt_alpha
      clt_beta=input$clt_beta
      #clt_beta=1
        #eps3=input$ep3
      clt_f=function(clt_n){sqrt(1:clt_n)*(cumsum(rgamma(clt_n,shape=clt_alpha,scale=clt_beta))/(1:clt_n)-clt_alpha*clt_beta)/sqrt(clt_alpha*(clt_beta**2))}
        clt_data_3D=data.frame()
        for (t in 1:clt_ns){
          clt_data_3D=rbind(clt_data_3D,clt_f(clt_n))
        }
        visualize.sp(data.matrix(clt_data_3D),nb.sp=clt_ns,epsilon=3,main=mtext(bquote(bold(.(clt_ns)~"sample paths of"~X[n])),col="darkblue"), col="grey")
        
    }))
      )

)
```


<div class = "clearfix"> </div>

### Homework practice
reference: https://www.probabilitycourse.com/chapter7/7_2_4_convergence_in_distribution.php \
Let $X_2, X_3,  X_4, \cdots $ be a sequence of random variable such that
$$F_{X_n}(x)=\begin{cases}
      1-(1-\frac{1}{n})^{nx} \ , \  x>0
      \\
      0 \ \ \ \ \ \ \ \ \ \ \ \ \ , \ otherwise
    \end{cases}    $$
Show that $X_n$ converges in distribution to Exponential(1).

<button type="button" class="collapsible">Solution</button>
<div class="content">
Solution: Let $X \sim Exponential (1)$. For $x \leq 0$, we have
$$F_{X_n}(x)=F_x(x)=0,$$ for $n=2,3,4,\cdots$.
For $x \geq 0$, we have 
$$ \begin{aligned} lim_{n \rightarrow \infty} F_{X_n}(x)&=lim_{n \rightarrow \infty} (1-(1-\frac{1}{n})^{nx}) \\
&=1-lim_{n\rightarrow \infty} (1-\frac{1}{n})^{nx} \\
&=1-e^{-x}\\
&=F_X(x)\end{aligned}$$, for all $x$.
Thus, we conclude that $X_n \stackrel {d}{\rightarrow}X$.
</div>

<div class = "clearfix"> </div>

## Convergence in Probability Definition 


A sequence of RVs $Y_1,...,Y_n,...$ converges in probability to a RV $Y$ if for every $\epsilon>0$
$$lim_{n\rightarrow\infty}P(|Y_n-Y|\geq \epsilon)=0 \iff 
lim_{n\rightarrow\infty}P(|Y_n-Y|<\epsilon)=1$$
Denoted by $Y_n\stackrel{p}{\rightarrow}Y$.  \\

We'll mostly care about convergence in probability to a constant, call it $c$.
$$lim_{n\rightarrow\infty}P(|Y_n-c|< \epsilon)=\lim_{n\rightarrow\infty}P(-\epsilon < Y_n-c<\epsilon) =  \lim_{n\rightarrow\infty}P(c-\epsilon < Y_n<c+\epsilon)=1$$

Convergence in probability idea - We will show that for a RS where the 
mean and variance exist the sequence 
$$\bar{Y}=\bar{Y}_{n}=\frac{1}{n}\sum_{i=1}^{n}Y_i\stackrel{p}\rightarrow 
E(Y)=\mu$$

<div class = "clearfix"> </div>


```{r, echo=FALSE,message=FALSE, eval = FALSE}
#Generate this many datasets
N <- 10000
#dummy vectors to store things
means <- rep(0, N)
#create data set of size i from normal, save sample mean of each sample.  True mean is 0.
for (i in 1:N){    
    means[i]<-mean(rnorm(n=i))
}
plot(x = 1:N, y = means, main = "Plot of Sample Mean Observations", xlab = "Number of data 
            values", ylab = "Value of Mean", cex = 0.1)
abline(h=0)
```


<div class = "clearfix"> </div>

##Convergence in probability idea

We will investigate the process of $X_n\stackrel{p}{\rightarrow}0$, where $X_1, X_2, X_3,..., X_n$ are a sequence of $iid$ random variables that $X_n=\frac{\sum_{i=1}^{n}Y_i}{n^2}$ and $Y_i\sim N(0,1)$.\\

- $n$ is the number of points in each sample path
- $M$ is the number of sample paths
- $\epsilon=0.05$
- Probability=$\frac{number \lvert X_n-0\rvert \geq \epsilon}{M}$ for each column

```{r, echo=FALSE, message=FALSE,warnings=FALSE, include=FALSE, eval = FALSE}
#Load library and set seed
#"formattable"

Packages <- c("ConvergenceConcepts","kableExtra","dplyr", "knitr","textshape","radiant.data", "magrittr","reshape2","ggplot2")

lapply(Packages, library, character.only = TRUE)
set.seed(1)

#Generate this many columns
n=10
#Simulate the sequence this many times
M=5
#Set up epsilon value
epsilon=0.05
#Define the function to generate the sequence
f=function(n){cumsum(rnorm(n))/((1:n)**2)}
#Generate dataset with n columns and M rows
data <- abs(round(generate(nmax=n,M=M,f)$data,digits=2))
#Extract the probability for each column that the distance between X and 0 is greater than epsilon
Pn_critr <- criterion(data,epsilon=epsilon,mode="p")$crit

#Rename the row name and column names of dateframe
data=data.frame(data)
rownames(data)=c("Sample path 1", "Sample path 2","Sample path 3","Sample path 4","Sample path 5")
colnames(data)=c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10")
data %>%
  kable(caption = "data") %>%
  kable_styling()
```



Convergence in probability is looking for the probability that the $|X_n-0|\geq\epsilon$ in each column.


```{r, echo=FALSE,message=FALSE, eval = FALSE}
#Add rownames to a column in order to melt
sample_path <- rownames(data)
datanew <- cbind(sample_path,data)
data_melted = melt(datanew, id.vars = 'sample_path')
ggplot(data_melted, aes(x = variable, y = value)) + geom_line(aes(color = sample_path, group =sample_path))+
  geom_hline(yintercept = epsilon,size=1,col="purple")+geom_hline(yintercept = -epsilon,size=1,col="purple")+
  annotate("rect", xmin = 3.75, xmax = 4.25, ymin = -0.75, ymax = 0.75,
  alpha = .2)+
  annotate("text",x = 4, y = 0.8, label = "hat(p[3])==0.8",parse = TRUE,col="darkblue")+
  theme_classic()+theme(plot.title = element_text(hjust = 0.5),plot.subtitle=element_text(hjust=0.5))+
     ggtitle("Probability of 5 Sample Paths as Sample Size Increases")+
     ylab("Probability") + 
     xlab("Sequence ") 
```



```{r,echo=FALSE,message=FALSE, eval = FALSE}
#Transpose column dataset probability and rename the column names
#caption = "<center> Probability for 5 Simuations <br>
                 # when sample size in 10 </center>"
probability=t(Pn_critr)
rownames(probability)="Probability"
colnames(probability)=c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10")
#produce data table and combind probability dataset
rbind(data,probability)%>%radiant.data::rownames_to_column()%>% 
mutate_if(is.numeric,function(x){
x=cell_spec(x,color = ifelse(x>=0.05,"red","black"))})%>%
textshape::column_to_rownames()%>%
kable(escape = F,row.names =T,caption = "<center> Probability for 5 Simuations 
                  with sample size 10 </center>", 
        align = "l" )%>%
kable_styling(bootstrap_options = c("striped", "hover"), full_width = T)%>%
row_spec(6, bold = T, color = "black", background = "lightblue")
```

<div class = "clearfix"> </div>
- $lim_{n\rightarrow\infty}P(|X_n-0|\geq \epsilon)=0$
- $X_n\stackrel{p}{\rightarrow}0$
<div class = "clearfix"> </div>
Let's graph the $p_n$ curve.
<div class = "clearfix"> </div>
```{r,echo=FALSE,message=FALSE, eval = FALSE}
#Plot the probability curve
plot(Pn_critr,xlab="n",ylab=bquote(hat(p[n])~"value"), main=mtext(bquote(bold("Criterion Value"~hat(p[n])~"Curve")),col="darkblue"),col="red",type="l")
text(x =n, y = max(Pn_critr),bquote(bold(hat(p[k])~"will tend to and stay at 0")),col="red",adj=1)
```


<div class = "clearfix"> </div>

##Details:  How do we prove convergence in probability?

-Markov's Inequality 
 * If $X$ is a nonnegative RV (support has no negative values) for which $E(X)$ exists, then for $t>0$
$$P(X\geq t)\leq \frac{E(X)}{t}$$

Example: If $X\sim exp(1)$ then $P(X\geq t)=e^{-t}$ and $E(X)/t=1/t$.

Chebychev's Inequality 

 Let $X$ be a RV with mean = $\mu$ and variance = $\sigma^2$, then for $t>0$ 
$$P(|X-\mu|\geq t)\leq \frac{\sigma^2}{t^2}$$

Example:  If $t=\sigma k$ for $k>0$, we can apply Chebychev's to get
$$P\left(|X-\mu|\geq k\sigma\right)\leq \frac{\sigma^2}{k^2\sigma^2}=\frac{1}{k^2}$$
For $k=2$ we have $P\left(|X-\mu|\geq 2\sigma\right)\leq 1/4$.


- At least 75\% of a RVs distribution lies within 2 standard deviations of the mean (if these moments exist)
- Regardless of distribution! (if moments exist)
- If $X\sim N(\mu,\sigma^2)$ we know $P(|X-\mu|\geq 2\sigma)\approx 0.05$. The bound isn't always very tight!




## Relating the inequalities to convergence in probability

Weak Law of Large Numbers (WLLN) 

- If $Y_1,Y_2,...$ is a sequence of independent RVs with $E(Y_i)=\mu$, $Var(Y_i)=\sigma^2$ then $\bar{Y}_{n}=\frac{1}{n}\sum_{i=1}^{n}Y_i\stackrel{p}{\rightarrow}\mu$


#Very powerful result!


- Big picture goal is to estimate parameters such as $\mu$.
- If we get a RS we know that $\bar{Y}$ will be a `close' to $\mu$ for `large' samples.


Example: $Y_i\stackrel{iid}{\sim}f_Y(y)$ where $E(Y_i^2)$ exists ($E\left(|Y_i^2|\right)<\infty$) then $Y_i^2$ are independent and all have the same expectation!

Example: If $Y_i\stackrel{iid}\sim f_Y(y)$ with $E(Y)=\mu$ and 
$Var(Y)=\sigma^2$ then 

##Continuity Theorem (works for all three types of convergence) 
- If $Y_1,Y_2,Y_3,...$ converge to $Y$ and $g$ is a continuous function then 
$g(Y_1),g(Y_2),g(Y_3)...$ converge to $g(Y)$. 

Example: Suppose $Y_i$ are independent each with mean $\mu$, we have interest 
in $\mu^2$.


A sequence of RVs $Y_1,...,Y_n,...$ converges in probability to a RV $Y$ if for every $\epsilon>0$
$$lim_{n\rightarrow\infty}P(|Y_n-Y|\geq \epsilon)=0 \iff 
lim_{n\rightarrow\infty}P(|Y_n-Y|<\epsilon)=1$$
Denoted by $Y_n\stackrel{p}{\rightarrow}Y$.  \\

We'll mostly care about convergence in probability to a constant, call it $c$.
$$lim_{n\rightarrow\infty}P(|Y_n-c|< \epsilon)=\lim_{n\rightarrow\infty}P(-\epsilon < Y_n-c<\epsilon) =  \lim_{n\rightarrow\infty}P(c-\epsilon < Y_n<c+\epsilon)=1$$


Other standard limit results exist such as
$$\mbox{If }Y\stackrel{p}{\rightarrow}\theta, 
X\stackrel{p}{\rightarrow}\lambda\mbox{ then }Y\pm 
X\stackrel{p}{\rightarrow}\theta\pm\lambda$$



